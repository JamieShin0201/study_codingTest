
*선택 정렬(Selection Sort)
- 알고리즘이 단순하고 사용할 수 있는 메모리가 제한적인 경우에 사용시 성능 상의 이점이 있다.
- 시간 복잡도가 Best, Average, Worst 에서 모두  O(n^2)​​이다.
- 2번째, 3번째 등 k번 째로 큰 값을 찾는 경우 유용하게 사용할 수 있다.
 => 이때 시간복잡도는 O(kn)

[과정]
1. 주어진 리스트 중에서 최소값을 찾는다.
2. 그 값을 맨 앞에 위치한 값과 교체한다.
3. 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.


[예시]
[9,1,6,8,4,3,2,0]  최솟값 0
[0,1,6,8,4,3,2,9]  최솟값 1
[0,1,6,8,4,3,2,9]  최솟값 2
[0,1,2,8,4,3,6,9]  최솟값 3
[0,1,2,3,4,8,6,9]  최솟값 4
[0,1,2,3,4,8,6,9]  최솟값 6
[0,1,2,3,4,6,8,9]  최솟값 8


*삽입 정렬(Insertion Sort)
- 데이터 집합을 순회하면서 정렬이 필요한 요소를 뽑아내어 이를 다시 적당한 곳에 삽입해 나가는 알고리즘
- 구현이 간단하고 평균적으로 O(n^2)의 시간복잡도를 갖는다.
- 리스트가 길어질수록 효율이 떨어진다. -> 자료의 이동이 많기 때문
[과정]
1. 데이터 집합에서 두 번째 자료부터 시작하여 대상이 되는 요소들을 선택합니다.

2. 정렬 대상의 가장 오른쪽에 있는 요소가 정렬 대상 중에서 가장 큰 값을 가지고 있는 지 확인합니다. 
만약 그렇지 않다면, 이 요소가 위치할 적절한 곳을 정렬 대상 내에서 찾아냅니다.

3. 적절한 위치를 지정했다면, 정렬 대상 내에서 삽입할 값보다 큰 값을 갖는 모든 자료를 한 자리씩 오른쪽으로 이동시키고, 
새로 생긴 빈 자리에 자료를 삽입합니다.

[예시] 초기데이터 [3,7,2,5,1,4]
[2,3,7,5,1,4]
[2,3,5,7,1,4]
[1,2,3,5,7,4]
[1,2,3,4,5,7]


*퀵 정렬(Quick Sort)
- 분할 정복 알고리즘의 하나로 매우 빠른 속도를 자랑한다.
- 최악의 경우 O(n^2), 최선 및 평균의 시간복잡도는 O(nlogn) 이다.

[과정]
1. 데이터 집합 내에서 임의의 요소를 선택한다. 이렇게 고른 요소를 피벗(pivot) 이라고 한다.

2. 분할(Divide): 데이터 집합을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 작은 요소들을 왼쪽, 큰 요소들을 오른쪽에 위치)로 분할한다.

3. 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 재귀적으로 이 과정을 반복한다.

4. 결합(Combine): 정렬된 부분 배열들을 하나의 배열로 합병시킨다.

[예시]
https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html


*버블 정렬(Bubble Sort)
- 인접한 두 원소를 검사하여 정렬하는 알고리즘
- 구현이 간단하고 평균적으로 O(N^2)의 시간 복잡도를 갖는다.

[과정]
1. 첫번째 원소와 두번째 원소를 비교하여 큰 값이 오른쪽에 오도록 한다.

2. 두번째 원소와 세번째 원소를 비교하여 큰 값이 오른쪽에 오도록 한다.

3. 위 과정을 데이터의 집합 크기 - 1(N - 1)만큼 반복하면 배열 맨 오른쪽에 가장 큰 값이 위치한다.

4. 위 과정을 (n-1), (n-2), (n-3)...회 반복한다.

[예시]
4 5 3 2 1 7
4 3 2 1 5 7
3 2 1 4 5 7
2 1 3 4 5 7
1 2 3 4 5 7


*병합/합병정렬(Merge Sort)
- 전체 원소를 하나의 단위로 분할한 후 분할한 원소를 다시 병합하는 정렬
- 최악의 시간 복잡도와 최고의 시간 복잡도는 O(nlogn)

[과정]
1. 리스트의 길이가 1이 될때까지 반으로 잘게 나눈다.
2. 다 나누어 졌다면, 데이터를 합치는데 정렬하면서 합친다.